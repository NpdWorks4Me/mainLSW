name: Deploy to Vercel

on: []

jobs:
  build-and-deploy:
    name: Build and Deploy (Vercel)
    # DISABLED: Prevent this job from running while we pause Vercel deploys.
    if: false
    runs-on: ubuntu-latest
    env:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
      VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
      VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Show node & npm
        run: |
          node --version
          npm --version

      - name: Ensure Vercel token is present
        run: |
          if [ -z "$VERCEL_TOKEN" ]; then echo "VERCEL_TOKEN is not set in the repository secrets" && exit 1; fi

      - name: Install root deps
        run: npm ci

      - name: Build site
        run: npm run build

      - name: Validate dist exists
        run: |
          echo "Contents of dist/ (top-level)"
          ls -la dist || (echo "dist does not exist" && exit 1)
          if [ ! -f dist/index.html ]; then echo "dist/index.html missing" && exit 1; fi

      - name: Pre-deploy: verify dist/index.html references present
        run: |
          set -euo pipefail
          echo "Verifying that every asset referenced in dist/index.html exists in dist/"
          grep -Eo 'src="(/[^"]+)"|href="(/[^"]+)"' dist/index.html | sed -E 's/.*("|\')(\/[^"'\']+)("|\')/\2/' | sort -u > /tmp/dist.assets || true
          MISSING=0
          while read -r p; do
            # Only check local paths
            case "$p" in
              /*)
                localpath="dist${p}"
                if [ ! -f "$localpath" ]; then
                  echo "Missing in dist/: $p (expected $localpath)" >&2
                  MISSING=1
                fi
                ;;
              *)
                echo "Skipping non-local asset: $p"
                ;;
            esac
          done < /tmp/dist.assets
          if [ "$MISSING" -ne 0 ]; then
            echo "One or more referenced assets are missing from dist/; aborting deploy" >&2
            exit 1
          fi

      - name: Print vercel version (debug)
        run: npx --yes vercel --version || true

      - name: Ensure static vercel.json in dist
        run: |
          echo 'Creating a vercel.json in dist to force static deployment'
          cat > dist/vercel.json <<'JSON'
          {
            "version": 2,
            "builds": [{ "src": "index.html", "use": "@vercel/static" }],
            "routes": [
              { "src": "^/assets/(.*)$", "dest": "/assets/$1" },
              { "src": "^/icons/(.*)$", "dest": "/icons/$1" },
              { "src": "^/sw.js$", "dest": "/sw.js" },
              { "src": "^/favicon.svg$", "dest": "/favicon.svg" },
              { "src": "^/manifest.json$", "dest": "/manifest.json" },
              { "src": "^/sitemap.xml$", "dest": "/sitemap.xml" },
              { "src": "^/(.*)$", "dest": "/index.html" }
            ]
          }
          JSON

      - name: Verify Vercel project id exists
        if: env.VERCEL_ORG_ID != '' && env.VERCEL_PROJECT_ID != ''
        run: |
          echo "Checking project id $VERCEL_PROJECT_ID in org $VERCEL_ORG_ID"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $VERCEL_TOKEN" "https://api.vercel.com/v1/projects/$VERCEL_PROJECT_ID?teamId=$VERCEL_ORG_ID")
          echo "Vercel API project lookup returned HTTP $HTTP_STATUS"
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "Project not found or token lacks access for $VERCEL_PROJECT_ID in org $VERCEL_ORG_ID" && exit 1
          fi

      # Temporarily disable the Vercel GitHub Action to avoid it creating a
      # remote build that can publish mismatched assets. We will perform a
      # controlled prebuilt deploy using the Vercel CLI below instead. Re-enable
      # this action if you prefer the action-based deploy flow.
      - name: Deploy to Vercel (Action)
        if: false
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          zeit-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prebuilt --prod --yes --cwd dist'

      - name: Deploy to Vercel (CLI)
        run: |
          echo "Deploying dist/ to Vercel using VERCEL_TOKEN"
          # If a project id is set in secrets but org id is not set, unset it so the CLI
          # will attempt to auto-detect the project instead of erroring out.
          if [ -n "$VERCEL_PROJECT_ID" ] && [ -z "$VERCEL_ORG_ID" ]; then
            echo "VERCEL_PROJECT_ID present and VERCEL_ORG_ID missing; unsetting VERCEL_PROJECT_ID so CLI auto-detects project"
            unset VERCEL_PROJECT_ID
          fi
          # Prefer a prebuilt deployment which uploads static files and skips a remote build.
          # Attempt a prebuilt deploy directly and fail loudly if it cannot succeed so
          # we don't silently fall back to remote builds which have produced
          # mismatched/absent assets historically.
          echo "Pre-deploy debug: listing 'dist' and checking config"
          echo "--- ls -la dist (first 200 lines) ---"
          ls -la dist | sed -n '1,200p' || true
          echo "--- du -sh dist ---"
          du -sh dist || true
          echo "--- cat dist/vercel.json ---"
          cat dist/vercel.json || true
          echo "--- git submodule status (if any) ---"
          git submodule status --recursive || echo "(no submodules or failed to fetch)"
          echo "--- Node & npm versions ---"
          node --version || true
          npm --version || true
          echo "--- vercel CLI version ---"
          npx --yes vercel --version || true
          echo "--- Environment VERCEL_* variables (masked values removed) ---"
          env | grep -E '^VERCEL_' || true

          echo "Attempting prebuilt deploy: vercel deploy --prebuilt --cwd dist"
          # Attempt prebuilt deploy and capture logs for diagnostics. Don't abort
          # the job here—upload diagnostic logs in a later step and then fail the
          # workflow explicitly so diagnostics are always available.
          set -o pipefail
          if npx --yes vercel deploy --prebuilt --cwd dist --token "$VERCEL_TOKEN" --prod --yes > /tmp/vercel_deploy_prebuilt.log 2>&1; then
            echo "Prebuilt deploy succeeded"
            sed -n '1,200p' /tmp/vercel_deploy_prebuilt.log || true
          else
            echo "Prebuilt deploy FAILED. Deployment log (first 200 lines):" >&2
            sed -n '1,200p' /tmp/vercel_deploy_prebuilt.log || true
            echo "Prebuilt deploy failed — continuing so we can upload diagnostics (artifacts)." >&2
          fi
        continue-on-error: true

      - name: Post-deploy smoke test (handles SSO bypass)
        if: env.VERCEL_PROJECT_ID != ''
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_SSO_BYPASS_TOKEN: ${{ secrets.VERCEL_SSO_BYPASS_TOKEN }}
          # Optional secret flag to allow treating API READY as success when bypass token is not available.
          ALLOW_READYSTATE_FALLBACK: ${{ secrets.ALLOW_READYSTATE_FALLBACK }}
        run: |
          set -euo pipefail
          echo "Fetching project info for $VERCEL_PROJECT_ID"
          curl -s -H "Authorization: Bearer $VERCEL_TOKEN" "https://api.vercel.com/v1/projects/$VERCEL_PROJECT_ID" -o /tmp/project.json
          echo "Raw project info saved to /tmp/project.json (first 200 chars):"
          head -c 200 /tmp/project.json || true

          # Extract a usable host/alias robustly from project metadata.
          # Handles shapes where `alias` may be ["host"] or [{"deployment": {"alias": ["host"]}}]
          URL=$(jq -r '
            ( .alias[]? as $a |
                (if ($a|type) == "string" then $a
                 elif ($a.deployment? // false) then ($a.deployment.alias[]?)
                 elif ($a.alias? // false) then ($a.alias[]?)
                 else empty end)
            ) // .latestDeployments[0].url // (.latestDeployments[0].alias[]? // empty) | select(.)' /tmp/project.json 2>/dev/null | head -n1 || true)

          if [ -z "$URL" ]; then
            echo "Could not determine deployment URL from project metadata" >&2
            echo "Project JSON (first 400 chars):" && head -c 400 /tmp/project.json || true
            exit 1
          fi

          # Normalize host (strip any https:// prefix if present)
          HOST=$(echo "$URL" | sed -E 's|^https?://||')
          echo "Detected deployment host: $HOST"

          echo "Attempting public GET https://$HOST"
          STATUS=$(curl -s -o /tmp/smoke.html -w "%{http_code}" -L "https://$HOST" || true)
          if [ -z "$STATUS" ]; then
            echo "Public GET produced no status code; possible network error or invalid host: $HOST" >&2
            STATUS=""
          fi
          echo "Public GET HTTP status: ${STATUS:-<none>}"
          if [ "$STATUS" = "200" ]; then
            echo "Smoke test passed (public 200)"
            exit 0
          fi

          if [ "$STATUS" = "401" ]; then
            echo "Received 401 from public GET; project is likely SSO-protected"
            if [ -z "${VERCEL_SSO_BYPASS_TOKEN-}" ]; then
              echo "VERCEL_SSO_BYPASS_TOKEN is not set in repository secrets. For SSO-protected projects you must set this secret to verify the site." >&2
              echo "If you intentionally want to keep SSO without a bypass token, set secret ALLOW_READYSTATE_FALLBACK=true to allow API READY to be treated as success." >&2
              # Check API ready state to offer helpful diagnostics
              READY_STATE=$(jq -r '.latestDeployments[0].readyState // .latestDeployments[0].status // .latestDeployments[0].state // empty' /tmp/project.json || true)
              echo "Deployment ready state: $READY_STATE"
              if [ "${ALLOW_READYSTATE_FALLBACK:-}" = "true" ] && [ "$READY_STATE" = "READY" ]; then
                echo "ALLOW_READYSTATE_FALLBACK is set and deployment is READY. Accepting as success (but add VERCEL_SSO_BYPASS_TOKEN to allow direct smoke-testing)."
                exit 0
              fi
              echo "Failing because SSO is detected but no bypass token is available." >&2
              exit 1
            fi

            echo "Retrying GET with VERCEL_SSO_BYPASS_TOKEN"
            STATUS2=$(curl -s -o /tmp/smoke.html -w "%{http_code}" -L -H "Authorization: Bearer $VERCEL_SSO_BYPASS_TOKEN" "https://$URL") || true
            echo "SSO-bypass GET HTTP status: $STATUS2"
            if [ "$STATUS2" = "200" ]; then
              echo "Smoke test passed using SSO bypass token"
              exit 0
            fi

            echo "SSO-bypass attempt did not return 200 (status: $STATUS2). Checking deployment ready state via Vercel API as a fallback"
            READY_STATE=$(jq -r '.latestDeployments[0].readyState // .latestDeployments[0].status // .latestDeployments[0].state // empty' /tmp/project.json || true)
            echo "Deployment ready state: $READY_STATE"
            if [ "$READY_STATE" = "READY" ]; then
              echo "Deployment is READY according to Vercel API, but SSO-bypass GET did not succeed (status: $STATUS2)." >&2
              echo "Treating as success for CI, but please verify the VERCEL_SSO_BYPASS_TOKEN value if you expect to validate page contents directly."
              exit 0
            fi

            echo "Smoke test failed after SSO-bypass attempt; status: $STATUS2" >&2
            head -n 50 /tmp/smoke.html || true
            exit 1
          fi

          echo "Smoke test failed; public GET returned status: $STATUS" >&2
          head -n 50 /tmp/smoke.html || true
          exit 1

      - name: Post-deploy asset verification
        if: env.VERCEL_PROJECT_ID != ''
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: |
          set -euo pipefail
          echo "Fetching project info for $VERCEL_PROJECT_ID (asset verification)"
          curl -s -H "Authorization: Bearer $VERCEL_TOKEN" "https://api.vercel.com/v1/projects/$VERCEL_PROJECT_ID" -o /tmp/project.json

          URL=$(jq -r '
            ( .alias[]? as $a |
                (if ($a|type) == "string" then $a
                 elif ($a.deployment? // false) then ($a.deployment.alias[]?)
                 elif ($a.alias? // false) then ($a.alias[]?)
                 else empty end)
            ) // .latestDeployments[0].url // (.latestDeployments[0].alias[]? // empty) | select(.)' /tmp/project.json 2>/dev/null | head -n1 || true)

          if [ -z "$URL" ]; then
            echo "Could not determine deployment URL from project metadata" >&2
            head -c 400 /tmp/project.json || true
            exit 1
          fi
          HOST=$(echo "$URL" | sed -E 's|^https?://||')
          echo "Detected deployment host: $HOST"

          echo "Downloading index.html from https://$HOST"
          curl -s -L "https://$HOST" -o /tmp/smoke.html || true

          # Normalize the downloaded HTML to a single line to robustly extract
          # attributes that may be split across lines in pretty-printed HTML.
          tr '\n' ' ' < /tmp/smoke.html | sed -E 's/ +/ /g' > /tmp/smoke_one_line.html || true

          # Extract asset URLs (scripts/styles/hrefs and common top-level files)
          ASSETS=$(grep -oE '(src|href)="/[^"']+"' /tmp/smoke_one_line.html | sed -E 's/^(src|href)="(\/[^"']+)"$/\2/' | grep -E '^/(assets|sw.js|favicon.svg|manifest.json|sitemap.xml|icons/)' | sort -u || true)

          if [ -z "$ASSETS" ]; then
            echo "Warning: could not find assets in index.html (possibly wrapped or unexpected markup)." >&2
            echo "Proceeding to fetch deployment file list for diagnostics. Outputting a snippet of the fetched index:" >&2
            head -n 200 /tmp/smoke.html || true
          fi

          MISSING=0
          if [ -n "$ASSETS" ]; then
            echo "Checking assets from index.html (unique):"
            echo "$ASSETS" | while read -r path; do
              echo " - Checking https://$HOST$path"
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" -L "https://$HOST$path" || true)
              if [ "$STATUS" != "200" ]; then
                echo "   -> MISSING or non-200 status: $STATUS" >&2
                MISSING=1
              else
                echo "   -> OK"
              fi
            done
          else
            echo "Skipped direct asset checks since no assets were discovered in index.html." >&2
            MISSING=1
          fi

          # Diagnostic: fetch the deployment's file list via Vercel API and
          # print any files under /assets so we can see whether the uploaded
          # deployment actually contains the expected asset files.
          DEPLOY_ID=$(jq -r '.latestDeployments[0].id // empty' /tmp/project.json || true)
          if [ -n "$DEPLOY_ID" ]; then
            echo "Fetching deployment file list for $DEPLOY_ID"
            curl -s -H "Authorization: Bearer $VERCEL_TOKEN" "https://api.vercel.com/v12/now/deployments/$DEPLOY_ID/files" -o /tmp/deploy_files.json || true
            echo "Files (matching /assets) in deployment $DEPLOY_ID:"
            jq -r '.[] | select(.file | test("^/assets/")) | .file' /tmp/deploy_files.json || echo "(none)"
          else
            echo "Could not determine deployment id for file listing" >&2
          fi

          if [ "$MISSING" -ne 0 ]; then
            echo "One or more assets referenced from index.html are not present on the deployment. This likely explains a blank/JS-less page."
            echo "Tips: prefer a prebuilt deploy (vercel deploy --prebuilt --cwd dist) so the exact built assets are uploaded, or ensure the remote build produces and publishes all assets."
            exit 1
          fi

      - name: Upload diagnostic files (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: vercel-deploy-diagnostics
          path: |
            /tmp/vercel_deploy_prebuilt.log
            /tmp/project.json
            /tmp/smoke.html
            /tmp/deploy_files.json

      - name: Playwright homepage smoke test (optional)
        if: always()
        run: |
          echo "Running Playwright homepage smoke test against https://$HOST"
          # Ensure Playwright is installed; npm ci is already run at the start of this job
          npx playwright install --with-deps || true
          export PLAYWRIGHT_SKIP_ADMIN_WEB_SERVER=true
          export BASE_URL="https://$HOST"
          # Run only the homepage smoke test to keep it fast and focused
          if npx playwright test tests/homepage.spec.js -g "Homepage smoke tests" --workers=1 --reporter=list; then
            echo "Playwright smoke test passed"
          else
            echo "Playwright smoke test failed; capturing a quick page snapshot for debugging"
            npx playwright show-report || true
            exit 1
          fi

      - name: Enforce prebuilt-deploy success (fail if prebuilt did not run)
        if: always()
        run: |
          if grep -q "Prebuilt deploy succeeded" /tmp/vercel_deploy_prebuilt.log 2>/dev/null; then
            echo "Prebuilt deploy succeeded"
            exit 0
          else
            echo "Prebuilt deploy did not succeed — failing the job to avoid a remote build fallback. See vercel-deploy-diagnostics artifact for details." >&2
            exit 1
          fi

          # If asset verification passed, run a lightweight Playwright smoke test
          # against the deployed host to ensure JS/CSS are being applied and the
          # page renders expected UI pieces. This is optional but provides an
          # additional real browser check beyond simple asset 200s.
          echo "Running Playwright homepage smoke test against https://$HOST"
          # Ensure Playwright is installed; npm ci is already run at the start of this job
          npx playwright install --with-deps || true
          export PLAYWRIGHT_SKIP_ADMIN_WEB_SERVER=true
          export BASE_URL="https://$HOST"
          # Run only the homepage smoke test to keep it fast and focused
          if npx playwright test tests/homepage.spec.js -g "Homepage smoke tests" --workers=1 --reporter=list; then
            echo "Playwright smoke test passed"
          else
            echo "Playwright smoke test failed; capturing a quick page snapshot for debugging"
            npx playwright show-report || true
            exit 1
          fi
